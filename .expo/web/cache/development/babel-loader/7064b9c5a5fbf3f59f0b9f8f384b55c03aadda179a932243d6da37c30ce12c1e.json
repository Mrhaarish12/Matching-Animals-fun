{"ast":null,"code":"var _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.calculateScore = calculateScore;\nexports.canCardsConnect = canCardsConnect;\nexports.default = void 0;\nexports.getInitialState = getInitialState;\nexports.getNeighbors = getNeighbors;\nexports.isLegalMove = isLegalMove;\nvar _shuffle = _interopRequireDefault(require(\"lodash/shuffle\"));\nvar _board = require(\"../constants/board\");\nvar _cards = require(\"../constants/cards\");\nvar _animals = require(\"../constants/animals\");\nvar snapshots = _interopRequireWildcard(require(\"./snapshots\"));\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\nfunction getNeighbors(G, id) {\n  var cells = G.cells;\n  var topCard = null,\n    rightCard = null,\n    bottomCard = null,\n    leftCard = null;\n  var topIndex = id - _board.columns,\n    rightIndex = id + 1,\n    leftIndex = id - 1,\n    bottomIndex = id + _board.columns;\n  if (topIndex >= 0) {\n    topCard = cells[topIndex];\n  }\n  if (bottomIndex < cells.length) {\n    bottomCard = cells[bottomIndex];\n  }\n  if (rightIndex % _board.columns !== 0 && rightIndex < cells.length - 1) {\n    rightCard = cells[rightIndex];\n  }\n  if (leftIndex % _board.columns !== _board.columns - 1 && leftIndex >= 0) {\n    leftCard = cells[leftIndex];\n  }\n  return {\n    topCard: topCard,\n    rightCard: rightCard,\n    bottomCard: bottomCard,\n    leftCard: leftCard\n  };\n}\nfunction calculateScore(G, ctx, id) {\n  var currentCard = G.deck[0];\n  var neighbors = getNeighbors(G, id);\n  var topCard = neighbors.topCard,\n    rightCard = neighbors.rightCard,\n    bottomCard = neighbors.bottomCard,\n    leftCard = neighbors.leftCard;\n  var score = 0;\n  if (topCard != null && currentCard.top === topCard.bottom) {\n    score += _animals.animals[topCard.bottom].score;\n  }\n  if (rightCard != null && currentCard.right === rightCard.left) {\n    score += _animals.animals[rightCard.left].score;\n  }\n  if (bottomCard != null && currentCard.bottom === bottomCard.top) {\n    score += _animals.animals[bottomCard.top].score;\n  }\n  if (leftCard != null && currentCard.left === leftCard.right) {\n    score += _animals.animals[leftCard.right].score;\n  }\n  return score;\n}\nfunction isLegalMove(G, ctx, id) {\n  if (G.cells[id] !== null) {\n    return false;\n  }\n  var currentCard = G.deck[0];\n  var neighbors = getNeighbors(G, id);\n  var topCard = neighbors.topCard,\n    rightCard = neighbors.rightCard,\n    bottomCard = neighbors.bottomCard,\n    leftCard = neighbors.leftCard;\n  if (topCard == null && rightCard == null && bottomCard == null && leftCard == null) {\n    return false;\n  }\n  if ((topCard == null || currentCard.top === topCard.bottom) && (rightCard == null || currentCard.right === rightCard.left) && (bottomCard == null || currentCard.bottom === bottomCard.top) && (leftCard == null || currentCard.left === leftCard.right)) {\n    return true;\n  }\n  return false;\n}\nfunction canCardsConnect(card1, card2) {\n  if (card1.top === card2.bottom || card1.bottom === card2.top || card1.left === card2.right || card1.right === card2.left) {\n    return true;\n  }\n  return false;\n}\nfunction getInitialState(ctx) {\n  var G = {\n    cells: [],\n    deck: [],\n    players: {}\n  };\n  for (var i = 0; i < ctx.numPlayers; i++) {\n    G.deck = G.deck.concat(_cards.deck);\n  }\n  G.deck = (0, _shuffle.default)(G.deck);\n  for (var j = 0; j < ctx.numPlayers; j++) {\n    G.players[j] = {\n      score: 0\n    };\n  }\n  G.cells = _board.cells;\n  var initialCard = (0, _cards.getRandomCard)(_cards.deck);\n  G.cells[_board.center] = initialCard;\n  while (!canCardsConnect(G.deck[0], initialCard)) {\n    G.deck.push(G.deck.shift());\n  }\n  return G;\n}\nvar game = {\n  setup: getInitialState,\n  turn: {\n    moveLimit: 1\n  },\n  moves: {\n    takeSnapshot: function takeSnapshot(G, ctx, id) {\n      console.log(\"==> takeSnapshot\", G);\n    },\n    restoreSnapshot: function restoreSnapshot(G, ctx, id) {\n      if (id) {\n        return snapshots[id];\n      }\n    },\n    placeCard: function placeCard(G, ctx, id) {\n      if (isLegalMove(G, ctx, id)) {\n        G.cells[id] = G.deck[0];\n        G.players[ctx.currentPlayer].score += calculateScore(G, ctx, id);\n        G.deck.shift();\n      }\n      return G;\n    },\n    pass: function pass(G, ctx) {\n      G.deck.push(G.deck.shift());\n      return G;\n    }\n  },\n  endIf: function endIf(G, ctx) {\n    if (G.deck.length === 0) {\n      var winner = Object.keys(G.players).reduce(function (previousPlayer, currentPlayer) {\n        return G.players[previousPlayer].score > G.players[currentPlayer].score ? previousPlayer : currentPlayer;\n      });\n      return winner;\n    }\n  }\n};\nvar _default = game;\nexports.default = _default;","map":{"version":3,"names":["_shuffle","_interopRequireDefault","require","_board","_cards","_animals","snapshots","_interopRequireWildcard","_getRequireWildcardCache","nodeInterop","WeakMap","cacheBabelInterop","cacheNodeInterop","obj","__esModule","default","cache","has","get","newObj","hasPropertyDescriptor","Object","defineProperty","getOwnPropertyDescriptor","key","prototype","hasOwnProperty","call","desc","set","getNeighbors","G","id","cells","topCard","rightCard","bottomCard","leftCard","topIndex","columns","rightIndex","leftIndex","bottomIndex","length","calculateScore","ctx","currentCard","deck","neighbors","score","top","bottom","animals","right","left","isLegalMove","canCardsConnect","card1","card2","getInitialState","players","i","numPlayers","concat","shuffle","j","emptyCells","initialCard","getRandomCard","center","push","shift","game","setup","turn","moveLimit","moves","takeSnapshot","console","log","restoreSnapshot","placeCard","currentPlayer","pass","endIf","winner","keys","reduce","previousPlayer","_default","exports"],"sources":["C:/Users/Estem/Desktop/matchimals.fun-main/src/Matchimals/game.js"],"sourcesContent":["import shuffle from \"lodash/shuffle\";\nimport { cells as emptyCells, center, columns } from \"../constants/board\";\nimport { deck, getRandomCard } from \"../constants/cards\";\nimport { animals } from \"../constants/animals\";\nimport * as snapshots from \"./snapshots\";\n\nexport function getNeighbors(G, id) {\n  const { cells } = G;\n\n  //Assume all are null\n  let topCard = null,\n    rightCard = null,\n    bottomCard = null,\n    leftCard = null;\n\n  // Find neighbor indices\n  const topIndex = id - columns,\n    rightIndex = id + 1,\n    leftIndex = id - 1,\n    bottomIndex = id + columns;\n\n  // Set as a neighbor card only if within board boundaries\n  if (topIndex >= 0) {\n    topCard = cells[topIndex];\n  }\n  if (bottomIndex < cells.length) {\n    bottomCard = cells[bottomIndex];\n  }\n  if (rightIndex % columns !== 0 && rightIndex < cells.length - 1) {\n    rightCard = cells[rightIndex];\n  }\n  if (leftIndex % columns !== columns - 1 && leftIndex >= 0) {\n    leftCard = cells[leftIndex];\n  }\n\n  return { topCard, rightCard, bottomCard, leftCard };\n}\n\nexport function calculateScore(G, ctx, id) {\n  const currentCard = G.deck[0];\n\n  //Assign neighbors\n  const neighbors = getNeighbors(G, id);\n  const topCard = neighbors.topCard,\n    rightCard = neighbors.rightCard,\n    bottomCard = neighbors.bottomCard,\n    leftCard = neighbors.leftCard;\n\n  //Calculate score for each matching side\n  let score = 0;\n  if (topCard != null && currentCard.top === topCard.bottom) {\n    score += animals[topCard.bottom].score;\n  }\n  if (rightCard != null && currentCard.right === rightCard.left) {\n    score += animals[rightCard.left].score;\n  }\n  if (bottomCard != null && currentCard.bottom === bottomCard.top) {\n    score += animals[bottomCard.top].score;\n  }\n  if (leftCard != null && currentCard.left === leftCard.right) {\n    score += animals[leftCard.right].score;\n  }\n  return score;\n}\n\nexport function isLegalMove(G, ctx, id) {\n  if (G.cells[id] !== null) {\n    return false;\n  }\n\n  const currentCard = G.deck[0];\n\n  //Assign neighbors\n  const neighbors = getNeighbors(G, id);\n  const topCard = neighbors.topCard,\n    rightCard = neighbors.rightCard,\n    bottomCard = neighbors.bottomCard,\n    leftCard = neighbors.leftCard;\n\n  // Check for matching side\n  if (\n    topCard == null &&\n    rightCard == null &&\n    bottomCard == null &&\n    leftCard == null\n  ) {\n    return false; //Return false if no neighbor cards exist\n  }\n\n  if (\n    (topCard == null || currentCard.top === topCard.bottom) &&\n    (rightCard == null || currentCard.right === rightCard.left) &&\n    (bottomCard == null || currentCard.bottom === bottomCard.top) &&\n    (leftCard == null || currentCard.left === leftCard.right)\n  ) {\n    return true; //Return true if there exists a match\n  }\n\n  return false; //Return false if there are no neighboring cards that match\n}\n\nexport function canCardsConnect(card1, card2) {\n  if (\n    card1.top === card2.bottom ||\n    card1.bottom === card2.top ||\n    card1.left === card2.right ||\n    card1.right === card2.left\n  ) {\n    return true;\n  }\n\n  return false;\n}\n\nexport function getInitialState(ctx) {\n  const G = {\n    cells: [],\n    deck: [],\n    players: {},\n  };\n\n  // Add a deck for every player\n  for (let i = 0; i < ctx.numPlayers; i++) {\n    G.deck = G.deck.concat(deck);\n  }\n\n  // Shuffle resulting deck using lodash\n  G.deck = shuffle(G.deck); // TODO: Use boardgame.io provided random shuffle function, which will be important when we are running a server\n\n  // Set up the game state for each player\n  for (let j = 0; j < ctx.numPlayers; j++) {\n    G.players[j] = {\n      score: 0,\n    };\n  }\n\n  // Fill the game board\n  G.cells = emptyCells;\n\n  // Set the initial card on the board\n  const initialCard = getRandomCard(deck); // TODO: Use boardgame.io provided random function\n  G.cells[center] = initialCard;\n\n  // Ensure the first card is connectable\n  while (!canCardsConnect(G.deck[0], initialCard)) {\n    G.deck.push(G.deck.shift()); // Place top card to bottom of deck, try again!\n  }\n\n  // For debugging \"game over\" state– this sets the deck to only have a single card\n  // G.deck = new Array(G.deck[0]);\n\n  // console.log(\"Initial Game State\", G, \"Initial ctx\", ctx);\n\n  // Our game state is ready to go– return it!\n  return G;\n}\n\nconst game = {\n  // The setup method is passed ctx\n  setup: getInitialState,\n\n  // End turn after a single move, whether it's placeCard or pass\n  turn: {\n    moveLimit: 1,\n  },\n\n  moves: {\n    takeSnapshot: (G, ctx, id) => {\n      console.log(\"==> takeSnapshot\", G);\n    },\n\n    restoreSnapshot: (G, ctx, id) => {\n      if (id) {\n        return snapshots[id];\n      }\n    },\n\n    // G and ctx are provided automatically when calling from App– `this.props.moves.placeCard(id)`\n    placeCard: (G, ctx, id) => {\n      // Ensure we can't overwrite cells.\n      if (isLegalMove(G, ctx, id)) {\n        //Lay the card on the board\n        G.cells[id] = G.deck[0];\n        G.players[ctx.currentPlayer].score += calculateScore(G, ctx, id);\n\n        //Next card shifts up the deck\n        G.deck.shift();\n      }\n\n      // Return the updated game state- because G is an Immer object we can mutate it directly\n      return G;\n    },\n\n    pass: (G, ctx) => {\n      // Place top card to bottom of deck\n      G.deck.push(G.deck.shift());\n\n      // Return the updated game state- because G is an Immer object we can mutate it directly\n      return G;\n    },\n  },\n\n  endIf: (G, ctx) => {\n    if (G.deck.length === 0) {\n      const winner = Object.keys(\n        G.players\n      ).reduce((previousPlayer, currentPlayer) =>\n        G.players[previousPlayer].score > G.players[currentPlayer].score\n          ? previousPlayer\n          : currentPlayer\n      );\n      return winner;\n    }\n  },\n};\n\nexport default game;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}